"""
A Pattern module for Sage Mathematics

Contains fast implementations for methods Patt.subwords using
dynamic programming and Patt.avoid by reducing redundant computations.
"""
# TODO: Profiling
# TODO: Test cases
# TODO: Calculate inverse of f_patts instead of ugly try/catch

# Used when compiling down to c
from sage.combinat.permutation import Permutations, Permutation


def flatten_(lst):
    """Return a flattened list

    Slow implementation, O(n^2)

    >>> flatten_(3, 8, 2)
    [2,3,1]
    """
    f = [0] * len(lst)
    c = list(lst)
    c.sort()
    c.reverse
    for x in xrange(len(lst)):
        f[lst.index(c[x])] = x + 1
    return f


class LengthPattern(object):
    """A Classical Pattern and a specific length of permutations"""
    def __init__(self, patt, perm_len):
        """Initialise LengthPattern with a classical pattern patt (list) and integer length perm_len (int)

        >>> LengthPattern([1,2,3,4], 10)
        LengthPattern [1, 2, 3, 4] with length 10"""
        # Confirm that patt is a valid permutation
        Permutation(patt)

        if perm_len <= len(patt):
            s = "Permutation length has to be larger than Pattern length"
            raise ValueError(s)

        self.patt = patt
        self.perm_len = perm_len

        # initializing method variables
        self.patt_len = len(patt)
        self.f_patts = [None] * self.patt_len
        self.below = [None] * self.patt_len
        self.above = [None] * self.patt_len

        # 2d array of subwords
        # patt_len nr. of rows
        # perm_len nr. of columns
        self.subword_matrix = [[[] for i in xrange(self.perm_len)] for j in xrange(self.patt_len)]

        # ugly block
        # find out index of value above and below i
        for i in xrange(self.patt_len):
            p = self.patt_len - i - 1
            self.f_patts[p] = flatten_(self.patt[i:])
            front = self.f_patts[p][0]
            try:  # smaller
                self.below[p] = self.f_patts[p].index(front - 1) - 1
            except:
                pass
            try:  # larger
                self.above[p] = self.f_patts[p].index(front + 1) - 1
            except:
                pass

    def subwords(self, perm):
        """Generator for subwords of perm that contain Patt

        Fast implementation, might allocate a lot of memory

        >>> [perm for perm in LengthPattern([1,2,3], 4).subwords([1,2,3,4])]
        [[2, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4]]"""

        # Confirm that perm is a valid Permutation
        Permutation(perm)

        # Confirm that perm is of compatible length
        if len(perm) != self.perm_len:
            raise Exception("""Permutation of incompatible length
    should be %d but received %d""" % (self.perm_len, len(perm)))
            return False

        subword_matrix = self.subword_matrix  # simplify code

        # First row
        for j in xrange(self.patt_len - 1, self.perm_len):
            subword_matrix[0][j] = []
            subword_matrix[0][j].append([perm[j]])

        # Following rows
        for j in reversed(xrange(self.perm_len)):    # column j
            for i in xrange(1, self.patt_len):       # row i
                # reuse initialized 2d matrix
                if len(subword_matrix[i][j]) > 0:
                    subword_matrix[i][j] = []

                # Skip corners of the matrix
                if j + i < self.patt_len - 1:  # top left corner
                    continue
                if j + i > self.perm_len - 1:  # bottom right corner
                    continue

                # prepend perm[j] to every possible smaller subword
                for k in xrange(j + 1, self.perm_len):
                    # for every little subword to prepend to
                    for subword in subword_matrix[i - 1][k]:
                        below = self.below[i]
                        if below is not None and perm[j] < subword[below]:
                            continue

                        above = self.above[i]
                        if above is not None and perm[j] > subword[above]:
                            continue

                        new_subw = [perm[j]] + subword

                        # length of patt reached?
                        if i == self.patt_len - 1:
                            yield new_subw
                        else:
                            subword_matrix[i][j].append(new_subw)

        raise StopIteration()  # No more subwords

    def __str__(self):
        return "LengthPattern %s with length %s" % (self.patt, self.perm_len)

    def __repr__(self):
        return "LengthPattern %s with length %s" % (self.patt, self.perm_len)


class Pattern(object):
    """A Classical Pattern"""
    def __init__(self, pattern):
        self.pattern = pattern
        self.patt_lens = set()
        self.patts = {}

    def clear_cache(self):
        """Clear memory allocated by self

        >>> p.clear_cache()
        Cache cleared"""
        self.patt_lens = set()
        self.patts = {}
        print "Cache cleared"

    def get_patt(self, perm):
        """Patt object with corresponding length for perm

        >>> Pattern([1,2,3]).get_patt([1,2,3,4])
        LengthPattern [1, 2, 3] with length 4"""
        if not len(perm) in self.patt_lens:
            self.patt_lens.add(len(perm))
            self.patts[len(perm)] = LengthPattern(self.pattern, len(perm))
        return self.patts[len(perm)]

    def subwords(self, perm):
        """Generator for subwords of perm containing Pattern

        >>> [perm for perm in Pattern([1,2,3]).subwords([1,5,2,4,3])]
        [[1, 2, 4], [1, 2, 3]]"""
        patt = self.get_patt(perm)
        return patt.subwords(perm)

    def subwords_list(self, perm):
        """List of subwords of perm containing Pattern

        >>> Pattern([1,2,3]).subwords_list([1,5,2,4,3])
        [[1, 2, 4], [1, 2, 3]]"""
        return list(subword for subword in self.subwords(perm))

    def subwords_print(self, perm):
        """Print out subwords of perm containing Pattern"""
        for subword in self.subwords(perm):
            print subword

    def avoided_by(self, perm):
        """True if perm avoids pattern, false otherwise

        >>> Pattern([1,2,3]).avoided_by([4,3,1,2,5])
        False
        >>> Pattern([1,2,3]).avoided_by([5,4,3,1,2])
        True"""
        for subword in self.subwords(perm):
            # we only need one subword
            return False
        return True

    def avoiders(self, n):
        """Generator for permutations of length n that avoid Pattern

        >>> [perm for perm in Pattern([1,2,3]).avoiders(4)]
        [[1, 4, 3, 2],
        [2, 1, 4, 3],
        [2, 4, 1, 3],
        [2, 4, 3, 1],
        [3, 1, 4, 2],
        [3, 2, 1, 4],
        [3, 2, 4, 1],
        [3, 4, 1, 2],
        [3, 4, 2, 1],
        [4, 1, 3, 2],
        [4, 2, 1, 3],
        [4, 2, 3, 1],
        [4, 3, 1, 2],
        [4, 3, 2, 1]]"""
        int(n)
        def derived_avoiders(perm):
            """docstring for derived_avoiders"""
            if self.avoided_by(perm):
                if len(perm) == n:
                    yield perm
                else:
                    for new_perm in self.expanded(perm):
                        yield from derived_avoiders(new_perm)

        for perm in Permutations(len(self.pattern) + 1):
            yield from derived_avoiders(perm)

    def avoiders_cardinality(self, n):
        """Number of permutations of length n that avoid Pattern

        >>> Pattern([1,2,3]).avoiders_cardinality(10)
        16796"""
        return len(self.avoiders_list(n))

    def avoiders_list(self, n):
        """List of permutations of length n that avoid Pattern

        >>> Pattern([1,2,3]).avoiders_list(4)
        [[1, 4, 3, 2],
        [2, 1, 4, 3],
        [2, 4, 1, 3],
        [2, 4, 3, 1],
        [3, 1, 4, 2],
        [3, 2, 1, 4],
        [3, 2, 4, 1],
        [3, 4, 1, 2],
        [3, 4, 2, 1],
        [4, 1, 3, 2],
        [4, 2, 1, 3],
        [4, 2, 3, 1],
        [4, 3, 1, 2],
        [4, 3, 2, 1]]"""
        return list(self.avoiders(n))

    def expanded(self, perm):
        """Generator for exansions of perm

        >>> [perm for perm in expand([1,2,3])]
        [[4, 1, 2, 3], [1, 4, 2, 3], [1, 2, 4, 3], [1, 2, 3, 4]]
        """
        n = len(perm) + 1
        for i in xrange(len(perm)):
            yield perm[:i] + [n] + perm[i:]
        yield perm + [n]

    def __str__(self):
        return "Pattern %s" % self.pattern

    def __repr__(self):
        return "Pattern %s" % self.pattern
