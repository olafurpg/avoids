Wrote profile results to avoids2.sage.lprof
Timer unit: 1e-06 s

File: avoids2.sage
Function: inverse_on at line 3
Total time: 2.12686 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
     3                                           @profile
     4                                           def inverse_on(patt, perm):
     5                                               """Applies perm on patt, perm and patt must be of equal length"""
     6    179900       210048      1.2      9.9      if len(patt) != len(patt):
     7                                                   print "trying to inverse permutations of unequal length"
     8                                                   sys.exit(0)
     9    179900       291739      1.6     13.7      inv = [0] * len(perm)
    10    715600       833624      1.2     39.2      for i in range(len(perm)):
    11                                                   # print i, perm, inv
    12    535700       630548      1.2     29.6          inv[perm[i] - 1] = patt[i]
    13    179900       160900      0.9      7.6      return inv

File: avoids2.sage
Function: is_sorted at line 15
Total time: 1.0747 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    15                                           @profile
    16                                           def is_sorted(lst):
    17                                               """returns true if lst is sorted, false otherwise"""
    18    471200       597200      1.3     55.6      for i in range(1, len(lst)):
    19    312800       319306      1.0     29.7          if lst[i] < lst[i - 1]:
    20     21500        24860      1.2      2.3              return False
    21    158400       133335      0.8     12.4      return True

File: avoids2.sage
Function: flatten_ at line 27
Total time: 0.000106 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    27                                           @profile
    28                                           def flatten_(lst):
    29                                               """return a flattened list, ex. flatten_(3, 4, 2) == [2,3,1]
    30                                               slow implementation, O(n^2)"""
    31         5           14      2.8     13.2      f = [0] * len(lst)
    32         5           10      2.0      9.4      c = list(lst)
    33         5           10      2.0      9.4      c.sort()
    34         5            7      1.4      6.6      c.reverse
    35        20           30      1.5     28.3      for x in xrange(len(lst)):
    36        15           30      2.0     28.3          f[lst.index(c[x])] = x + 1
    37         5            5      1.0      4.7      return f

File: avoids2.sage
Function: avoids_it at line 88
Total time: 0 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    88                                           @profile
    89                                           def avoids_it(perm, patt):
    90                                               """Returns a list of lists of subwords of perm of length l using dynamic programming
    91                                               L == is the original length"""
    92                                               # initializing method variables
    93                                               perm_len = len(perm)
    94                                               patt_len = len(patt)
    95                                               diff = perm_len - patt_len
    96                                               f_patts = [None] * patt_len
    97                                               sw = [[[] for i in range(perm_len)] for j in range(patt_len)]
    98                                           
    99                                               # set up
   100                                               for j in range(patt_len - 1, perm_len):
   101                                                   sw[0][j].append([perm[j]])
   102                                               for i in range(patt_len):
   103                                                   f_patts[patt_len - i - 1] = flatten_(patt[i:])
   104                                               # print f_patts[patt_len - 1]
   105                                               # prt_2d(sw)
   106                                               # iterate through 2d matrix
   107                                               for j in reversed(range(perm_len)): # column j
   108                                                   for i in range(1, patt_len):       # row i
   109                                                       # print i, j, diff
   110                                                       if j + i < patt_len - 1: # top left corner
   111                                                           continue
   112                                                       if j + i > perm_len - 1: # bottom right corner
   113                                                           continue
   114                                                       # prt_2d(sw)
   115                                                       # prepend perm[j] to every possible smaller subword
   116                                                       for k in range(j + 1, perm_len):
   117                                                           for sub in sw[i - 1][k]: # for every little subword to prepend to
   118                                                               if (perm[j] < sub[0]) != (f_patts[i][0] < f_patts[i][1]): # 20% increase
   119                                                                   continue # heads of patt and new subword don't match
   120                                                               new_subw = [perm[j]] + sub
   121                                                               if is_in(new_subw, f_patts[i]):
   122                                                                   if i == patt_len - 1: # Found total pattern in permutation
   123                                                                       # print "Founds new_subw=%s in patt=%s" % (new_subw, patt)
   124                                                                       return False
   125                                                                   sw[i][j].append([perm[j]] + sub)
   126                                               return True # did not find pattern in permutation

File: avoids2.sage
Function: is_contained_in at line 142
Total time: 15.2709 s

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   142                                               @profile
   143                                               def is_contained_in(self, perm):
   144                                                   # print self.patt, perm
   145     10000        13791      1.4      0.1          if len(perm) != self.perm_len:
   146                                                       print "Permutation of incompatible length, should be %d, received %d" %(self.perm_len, len(perm))
   147                                                       return False
   148     60000        74598      1.2      0.5          for j in range(self.patt_len - 1, self.perm_len):
   149     50000        76945      1.5      0.5              self.sw[0][j] = []
   150     50000        84351      1.7      0.6              self.sw[0][j].append([perm[j]])
   151                                                   # prt_2d(self.sw)
   152                                                   # prt_2d(self.sw)
   153     95600       117547      1.2      0.8          for j in reversed(range(self.perm_len)):    # column j
   154    435600       549244      1.3      3.6              for i in range(1, self.patt_len):       # row i
   155                                                           # print i, j
   156    350000       478821      1.4      3.1                  if len(self.sw[i][j]) > 0:
   157     65296       121144      1.9      0.8                      self.sw[i][j] = [] # reuse initialized 2d matrix
   158    350000       439118      1.3      2.9                  if j + i < self.patt_len - 1: # top left corner
   159     54200        53524      1.0      0.4                      continue
   160    295800       363192      1.2      2.4                  if j + i > self.perm_len - 1: # bottom right corner
   161    100000        98258      1.0      0.6                      continue
   162                                                           # prepend perm[j] to every possible smaller subword
   163   1055100      1306575      1.2      8.6                  for k in range(j + 1, self.perm_len):
   164   1310200      1744533      1.3     11.4                      for sub in self.sw[i - 1][k]: # for every little subword to prepend to
   165    450900       757377      1.7      5.0                          if (perm[j] < sub[0]) != (self.f_patts[i][0] < self.f_patts[i][1]): # 20% increase
   166                                                                       # print "Continuing"
   167    271000       271068      1.0      1.8                              continue # heads of patt and new subword don't match
   168    179900       301179      1.7      2.0                          new_subw = [perm[j]] + sub
   169                                           
   170                                                                   # print new_subw, self.f_patts[i], is_in(new_subw, self.f_patts[i])
   171    179900      7954196     44.2     52.1                          if is_in(new_subw, self.f_patts[i]):
   172    158400       202293      1.3      1.3                              if i == self.patt_len - 1: # Found total pattern in permutation
   173                                                                           # print "Founds patt=%s, subw=%s in perm=%s" % (self.patt, new_subw, perm)
   174      1900         3278      1.7      0.0                                  return False
   175                                                                       # print self.sw[i][j], new_subw
   176    156500       251306      1.6      1.6                              self.sw[i][j].append(new_subw)
   177                                                                   # else do nothing. the subword is not in the pattern
   178                                                                   # prt_2d(self.sw)
   179                                           
   180      8100         8550      1.1      0.1          return True # did not find pattern in permutation

