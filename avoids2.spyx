import sys
from sage.combinat.permutation import Permutations

def flatten_(lst):
    """Return a flattened list, slow implementation, O(n^2)
    >>> flatten_(3, 8, 2)
    [2,3,1]
    """
    f = [0] * len(lst)
    c = list(lst)
    c.sort()
    c.reverse
    for x in xrange(len(lst)):
        f[lst.index(c[x])] = x + 1
    return f

def prt_2d(arr):
    print ""
    for row in arr:
        print row

class Patt(object):
    """A pattern object is a classical pattern along with a specific length (int).

    Can check if the pattern is contained in any permutation with the given length
    """
    def __init__(self, patt):
        self.patt = patt
        # initializing method variables
        self.patt_len = len(patt)
        self.f_patts = [None] * self.patt_len
        self.f_smaller = [None] * self.patt_len
        self.f_larger = [None] * self.patt_len
        self.subwords = {}
        self.sws = None
        # [[[] for i in xrange(self.perm_len)] for j in xrange(self.patt_len)]

        # set up
        for i in xrange(self.patt_len):
            p = self.patt_len - i - 1
            self.f_patts[p] = flatten_(self.patt[i:])
            front = self.f_patts[p][0]
            try: # smaller
                self.f_smaller[p] = self.f_patts[p].index(front - 1) - 1
            except:
                pass
            try: # larger
                self.f_larger[p] = self.f_patts[p].index(front + 1) - 1
            except:
                pass
            # print i + 1, p ,  self.f_patts[p], self.f_smaller[p], self.f_larger[p]

#     @profile
    def contained_in(self, perm):
        perm_len = len(perm)
        if not self.subwords[perm_len]:
            fresh = [[[] for i in xrange(perm_len)] for j in xrange(self.patt_len)]
            self.subwords[perm_len] = fresh
        self.sw = self.subwords[perm_len]
        # First row, subwords of length 1
        for j in xrange(self.patt_len - 1, self.perm_len):
            self.sw[0][j] = []
            self.sw[0][j].append([perm[j]])
        for j in reversed(xrange(self.perm_len)):    # column j
            for i in xrange(1, self.patt_len):       # row i
                # print i, j
                if len(self.sw[i][j]) > 0:
                    self.sw[i][j] = [] # reuse initialized 2d matrix
                if j + i < self.patt_len - 1: # top left corner
                    continue
                if j + i > self.perm_len - 1: # bottom right corner
                    continue
                # prepend perm[j] to every possible smaller subword
                for k in xrange(j + 1, self.perm_len):
                    for sub in self.sw[i - 1][k]: # for every little subword to prepend to
                        if (not self.f_smaller[i] and perm[j] < sub[self.f_smaller[i]]) or \
                            (not self.f_larger[i] and perm[j] > sub[self.f_larger[i]]):
                            continue
                        if i == self.patt_len - 1: # patt length reached
                            # perm contains patt
                            return True
                        
                        new_subw = [perm[j]] + sub
                        self.sw[i][j].append(new_subw)

        return False # did not find pattern in permutation

    def avoiders(self, perm_len):
        """Counts the number of permutations of length perm_len that 
        avoid the given pattern patt"""
        Perms = Permutations(perm_len)
        f = lambda perm : not self.contained_in(perm)
        return Perms.filter(f).cardinality()


    def __str__(self):
        return "Pattern %s" % self.patt

    def __repr__(self):
        return "Pattern %s" % self.patt

def avoids(perm, patt):
    """Initializes a Patt object and calls method is_contained_by to check for avoidance"""
    P = Patt(patt, len(perm))
    return P.contained_in(perm)


