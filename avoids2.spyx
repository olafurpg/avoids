import sys
from cython cimport view
cimport numpy as np

cdef unsigned int index(np.ndarray[long, ndim=1] u, val):
    """docstring for index"""
    cdef unsigned int i
    cdef long v = val
    for i in xrange(u.shape[0]):
        if u[i] == v:
            return i

def cflatten(np.ndarray[long, ndim=1] lst):
    """Return a flattened numpy array, slow implementation, O(n^2)
    >>> flatten_(3, 8, 2)
    [2,3,1]
    """
    f = [0] * lst.shape[0]
    c = np.copy(lst)
    c.sort()
    c = c[::-1]
    for x in xrange(len(lst)):
        f[index(lst, c[x]c)] = x + 1
    return f



def flatten_(lst):
    """Return a flattened list, slow implementation, O(n^2)
    >>> flatten_(3, 8, 2)
    [2,3,1]
    """
    f = [0] * len(lst)
    c = list(lst)
    c.sort()
    c.reverse
    for x in xrange(len(lst)):
        f[lst.index(c[x])] = x + 1
    return f

def prt_2d(arr):
    print ""
    for row in arr:
        print row

 
class cPatt(object):
    """A pattern object is a classical pattern along with a specific length (int).  """
    
    def __init__(self, patt, perm_len):
        self.patt = np.array(patt)
        cdef unsigned int self.perm_len = perm_len
        # initializing method variables
        cdef unsigned int self.patt_len = len(patt)
        self.f_patts = np.zeros([self.patt_len])
        self.f_smaller = np.zeros([self.patt_len])
        self.f_larger = np.zeros([self.patt_len])
        self.sw = [[[] for i in range(self.perm_len)] for j in range(self.patt_len)]

        # set up
        for i in range(self.patt_len):
            p = self.patt_len - i - 1
            self.f_patts[p] = cflatten(self.patt[i:])
            front = self.f_patts[p][0]
            try: # smaller
                self.f_smaller[p] = self.f_patts[p].index(front - 1) - 1
                # self.f_smaller[p] = np.nonzero(self.f_patts[p] == front - 1)[0][0] - 1
            except:
                pass
            try: # larger
                # self.f_larger[p] = self.f_patts[p].index(front + 1) - 1
                self.f_larger[p] = np.nonzero(self.f_patts[p] == front + 1)[0][0] - 1
            except:
                pass
            # print i + 1, p ,  self.f_patts[p], self.f_smaller[p], self.f_larger[p]

#     @profile
    def is_contained_in(self, perm):
        """Checks if the pattern is contained in any permutation with the given length"""
        # print self.patt, perm
        if len(perm) != self.perm_len:
            print "Permutation of incompatible length, should be %d, received %d" %(self.perm_len, len(perm))
            return False
        for j in range(self.patt_len - 1, self.perm_len):
            self.sw[0][j] = []
            self.sw[0][j].append([perm[j]])
        # prt_2d(self.sw)
        # prt_2d(self.sw)
        for j in reversed(range(self.perm_len)):    # column j
            for i in range(1, self.patt_len):       # row i
                # print i, j
                if len(self.sw[i][j]) > 0:
                    self.sw[i][j] = [] # reuse initialized 2d matrix
                if j + i < self.patt_len - 1: # top left corner
                    continue
                if j + i > self.perm_len - 1: # bottom right corner
                    continue
                # prepend perm[j] to every possible smaller subword
                for k in range(j + 1, self.perm_len):
                    for sub in self.sw[i - 1][k]: # for every little subword to prepend to
                        new_subw = [perm[j]] + sub
                        if (self.f_smaller[i] is not None and perm[j] < sub[self.f_smaller[i]]) or \
                                (self.f_larger[i] is not None and perm[j] > sub[self.f_larger[i]]):
                            continue
                        if i == self.patt_len - 1:
                            return False
                        self.sw[i][j].append(new_subw)

        return True # did not find pattern in permutation

    def __str__(self):
        return "Pattern %s" % self.patt

    def __repr__(self):
        return "Pattern %s" % self.patt



class Patt(object):
    """A pattern object is a classical pattern along with a specific length (int).

    Can check if the pattern is contained in any permutation with the given length
    """
    def __init__(self, patt, perm_len):
        self.patt = patt
        self.perm_len = perm_len
        # initializing method variables
        self.patt_len = len(patt)
        self.f_patts = [None] * self.patt_len
        self.f_smaller = [None] * self.patt_len
        self.f_larger = [None] * self.patt_len
        self.sw = [[[] for i in range(self.perm_len)] for j in range(self.patt_len)]

        # set up
        for i in range(self.patt_len):
            p = self.patt_len - i - 1
            self.f_patts[p] = flatten_(self.patt[i:])
            front = self.f_patts[p][0]
            try: # smaller
                self.f_smaller[p] = self.f_patts[p].index(front - 1) - 1
            except:
                pass
            try: # larger
                self.f_larger[p] = self.f_patts[p].index(front + 1) - 1
            except:
                pass
            # print i + 1, p ,  self.f_patts[p], self.f_smaller[p], self.f_larger[p]

#     @profile
    def is_contained_in(self, perm):
        # print self.patt, perm
        if len(perm) != self.perm_len:
            print "Permutation of incompatible length, should be %d, received %d" %(self.perm_len, len(perm))
            return False
        for j in range(self.patt_len - 1, self.perm_len):
            self.sw[0][j] = []
            self.sw[0][j].append([perm[j]])
        # prt_2d(self.sw)
        # prt_2d(self.sw)
        for j in reversed(range(self.perm_len)):    # column j
            for i in range(1, self.patt_len):       # row i
                # print i, j
                if len(self.sw[i][j]) > 0:
                    self.sw[i][j] = [] # reuse initialized 2d matrix
                if j + i < self.patt_len - 1: # top left corner
                    continue
                if j + i > self.perm_len - 1: # bottom right corner
                    continue
                # prepend perm[j] to every possible smaller subword
                for k in range(j + 1, self.perm_len):
                    for sub in self.sw[i - 1][k]: # for every little subword to prepend to
                        new_subw = [perm[j]] + sub
                        if (self.f_smaller[i] is not None and perm[j] < sub[self.f_smaller[i]]) or \
                                (self.f_larger[i] is not None and perm[j] > sub[self.f_larger[i]]):
                            continue
                        if i == self.patt_len - 1:
                            return False
                        self.sw[i][j].append(new_subw)

        return True # did not find pattern in permutation

    def __str__(self):
        return "Pattern %s" % self.patt

    def __repr__(self):
        return "Pattern %s" % self.patt

def avoids(perm, patt):
    """Initializes a Patt object and calls method is_contained_by to check for avoidance"""
    P = Patt(patt, len(perm))
    return P.is_contained_in(perm)
